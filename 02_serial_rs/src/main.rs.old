use gpio_cdev::{Chip, LineRequestFlags};
use tokio_serial::{SerialPortBuilderExt, SerialStream};
use tokio::io::{AsyncBufReadExt, BufReader};
use regex::Regex;
use std::error::Error;

const LED_GPIO: u32 = 4;  // GPIO4 (Pin 7 on Raspberry Pi)

/// Auto-detect Arduino's serial port
async fn find_arduino_port() -> Result<String, Box<dyn Error>> {
    let ports = tokio_serial::available_ports()?;
    let arduino_regex = Regex::new(r"(ACM|USB|ttyUSB|ttyACM)")?;

    ports.into_iter()
        .find(|port| arduino_regex.is_match(&port.port_name))
        .map(|port| port.port_name)
        .ok_or("No Arduino port found".into())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // GPIO Setup
    let mut chip = Chip::new("/dev/gpiochip0")?;
    let line = chip.get_line(LED_GPIO)?;
    let mut led = line.request(LineRequestFlags::OUTPUT, 0, "distance_led")?;

    // Auto-detect and open serial port
    let port_path = find_arduino_port().await?;
    println!("Found Arduino at: {}", port_path);
    
    let mut port = tokio_serial::new(&port_path, 9600)
        .open_native_async()?;

    let mut reader = BufReader::new(port);
    let mut line = String::new();

    loop {
        line.clear();
        reader.read_line(&mut line).await?;
        
        if line.starts_with("Distance: ") {
            if let Some(distance_str) = line.split_whitespace().nth(1) {
                if let Ok(distance) = distance_str.parse::<f32>() {
                    println!("Distance: {} cm", distance);
                    
                    // Control LED
                    led.set_value(if distance < 20.0 { 1 } else { 0 })?;
                }
            }
        }
    }
}
